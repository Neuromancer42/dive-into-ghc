@misc{alex,
	title="Alex: A lexical analyser generator for Haskell",
	author="Simon Marlow",
	url="https://www.haskell.org/alex/"
}
@misc{happy,
title="Happy: The Parser Generator for Haskell",
author="Simon Marlow",
url="https://www.haskell.org/happy/"
}
@misc{ghcparser,
title="ghc/compiler/parser/",
author="The GHC team",
url="https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/parser"
}
@misc{ghcrename,
title="ghc/compiler/rename/",
author="The GHC team",
url="https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/rename"
}
@MISC{Hutton96monadicparser,
author = "Graham Hutton and Erik Meijer",
title = "Monadic Parser Combinators",
year = "1996"
}
@misc{parsec,
title = "Parsec, a fast combinator parser",
author = "Daan Leijen",
year = "2001"
}
@INPROCEEDINGS{Frost07parsercombinators,
author = "Richard A. Frost and Rahmatullah Hafiz and Paul Callaghan",
title = "Parser combinators for ambiguous left-recursive grammars",
booktitle = "In ????, pages",
year = "2007"
}
@article{FROST1996263,
title = "Memoizing purely functional top-down backtracking language processors",
journal = "Science of Computer Programming",
volume = "27",
number = "3",
pages = "263 - 288",
year = "1996",
note = "",
issn = "0167-6423",
doi = "http://dx.doi.org/10.1016/0167-6423(96)00014-7",
url = "http://www.sciencedirect.com/science/article/pii/0167642396000147",
author = "Richard A Frost and Barbara Szydlowski"

}
@misc{haskell2010,
title="Haskell 2010 Language Report",
author="The Haskell community",
url="https://www.haskell.org/onlinereport/haskell2010/haskell.html"
}
@article{hindley1969,
	ISSN = {00029947},
	URL = {http://www.jstor.org/stable/1995158},
	author = {R. Hindley},
	journal = {Transactions of the American Mathematical Society},
	pages = {29-60},
	publisher = {American Mathematical Society},
	title = {The Principal Type-Scheme of an Object in Combinatory Logic},
	volume = {146},
	year = {1969}
}
@article{MILNER1978348,
	title = "A theory of type polymorphism in programming",
	journal = "Journal of Computer and System Sciences",
	volume = "17",
	number = "3",
	pages = "348 - 375",
	year = "1978",
	note = "",
	issn = "0022-0000",
	doi = "http://dx.doi.org/10.1016/0022-0000(78)90014-4",
	url = "http://www.sciencedirect.com/science/article/pii/0022000078900144",
	author = "Robin Milner",
	
}
@article{WELLS1999111,
	title = "Typability and type checking in System F are equivalent and undecidable",
	journal = "Annals of Pure and Applied Logic",
	volume = "98",
	number = "1",
	pages = "111 - 156",
	year = "1999",
	note = "",
	issn = "0168-0072",
	doi = "http://dx.doi.org/10.1016/S0168-0072(98)00047-5",
	url = "http://www.sciencedirect.com/science/article/pii/S0168007298000475",
	author = "J.B. Wells",
	keywords = "System F",
	keywords = "Semi-unification",
	keywords = "Type inference",
	keywords = "Typability",
	keywords = "Type checking",
	keywords = "Lambda calculus"
}
@misc{GHClangfeatures,
title="GHC Language Features",
author="The GHC team",
url="http://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/ghc-language-features.html"
}
@article{FCimpl,
title="System FC, as implemented in GHC",
author="R. A. Eisenberg",
journal="University of Pennsylvania Department of Computer and Information Science Technical Report",
volume="MS-CIS-15-09",
year="2015",
url="http://repository.brynmawr.edu/compsci_pubs/15/"
}
@inproceedings{Sulzmann:2007:SFT:1190315.1190324,
	author = "Sulzmann, Martin and Chakravarty, Manuel M. T. and Jones, Simon Peyton and Donnelly, Kevin",
	title = "System F with Type Equality Coercions",
	booktitle = "Proceedings of the 2007 ACM SIGPLAN International Workshop on Types in Languages Design and Implementation",
	series = "TLDI '07",
	year = "2007",
	isbn = "1-59593-393-X",
	location = "Nice, Nice, France",
	pages = "53--66",
	numpages = "14",
	url = "http://doi.acm.org/10.1145/1190315.1190324",
	doi = "10.1145/1190315.1190324",
	acmid = "1190324",
	publisher = "ACM",
	address = "New York, NY, USA",
	keywords = "advanced type features, typed intermediate language",
} 
@article{outsideinx-modular-type-inference-with-local-assumptions,
	author = {Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom and Sulzmann, Martin},
	title = {OutsideIn(X): Modular type inference with local assumptions},
	booktitle = {},
	year = {2011},
	month = {September},
	abstract = {
	
	Advanced type system features, such as GADTs, type classes and type families, have proven to be invaluable language extensions for ensuring data invariants and program correctness. Unfortunately, they pose a tough problem for type inference when they are used as local type assumptions. Local type assumptions often result in the lack of principal types and cast the generalisation of local let-bindings prohibitively difficult to implement and specify. User-declared axioms only make this situation worse. In this paper, we explain the problems and-perhaps controversially-argue for abandoning local let-binding generalisation. We give empirical results that local let generalisation is only sporadically used by Haskell programmers. Moving on, we present a novel constraint-based type inference approach for local type assumptions. Our system, called OutsideIn(X), is parameterised over the particular underlying constraint domain X, in the same way as HM(X). This stratification allows us to use a common metatheory and inference algorithm. OutsideIn(X) extends the constraints of X by introducing implication constraints on top. We describe the strategy for solving these implication constraints, which, in turn, relies on a constraint solver for X. We characterise the properties of the constraint solver for X so that the resulting algorithm only accepts programs with principal types, even when the type system specification accepts programs that do not enjoy principal types. Going beyond the general framework, we give a particular constraint solver for X = type classes + GADTs + type families, a non-trivial challenge in its own right. This constraint solver has been implemented and distributed as part of GHC 7.
	
	
	},
	publisher = {Cambridge University Press},
	url = {https://www.microsoft.com/en-us/research/publication/outsideinx-modular-type-inference-with-local-assumptions/},
	address = {},
	pages = {333–412},
	journal = {Journal of Functional Programming},
	volume = {21},
	chapter = {},
	isbn = {},
}
@misc{ghcprim,
author="The GHC team",
url="https://hackage.haskell.org/package/ghc-prim",
title="The ghc-prim package"
}
@article{implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine,
	author = {Peyton Jones, Simon},
	title = {Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine},
	booktitle = {},
	year = {1992},
	month = {July},
	abstract = {
	
	The Spineless Tagless G-machine is an abstract machine designed to support non- strict higher-order functional languages. This presentation of the machine falls into three parts. Firstly, we give a general discussion of the design issues involved in implementing non-strict functional languages.
	Next, we present the STG language, an austere but recognisably-functional language, which as well as a denotational meaning has a well-defined operational semantics. The STG language is the \abstract machine code" for the Spineless Tagless G-machine.
	Lastly, we discuss the mapping of the STG language onto stock hardware. The success of an abstract machine model depends largely on how efficient this mapping can be made, though this topic is often relegated to a short section. Instead, we give a detailed discussion of the design issues and the choices we have made. Our principal target is the C language, treating the C compiler as a portable assembler.
	
	
	},
	publisher = {Cambridge University Press},
	url = {https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/},
	address = {},
	pages = {127–202},
	journal = {Journal of Functional Programming},
	volume = {2},
	chapter = {},
	isbn = {},
}
@inproceedings{make-fast-curry-pushenter-vs-evalapply,
	author = {Peyton Jones, Simon},
	title = {How to make a fast curry: push/enter vs eval/apply},
	booktitle = {},
	year = {2004},
	month = {September},
	abstract = {Higher-order languages that encourage currying are typically implemented using one of two basic evaluation models: push/enter or eval/apply. Implementors use their intuition and qualitative judgements to choose one model or the other.
	
	Our goal in this paper is to provide, for the first time, a more substantial basis for this choice, based on our qualitative and quantitative experience of implementing both models in a state-of-the-art compiler for Haskell.
	
	Our conclusion is simple, and contradicts our initial intuition: compiled implementations should use eval/apply.
	
	Conference version (2004) 
	Slides of talk 
	
	&nbsp;},
	publisher = {},
	url = {https://www.microsoft.com/en-us/research/publication/make-fast-curry-pushenter-vs-evalapply/},
	address = {},
	pages = {4-15},
	journal = {},
	volume = {},
	chapter = {},
	isbn = {},
}
@inproceedings{c-a-portable-assembly-language,
	author = {Oliva, Dino and Nordin, T. and Peyton Jones, Simon},
	title = {C–: A Portable Assembly Language},
	booktitle = {Proceedings of the 1997 Workshop on Implementing Functional Languages},
	year = {1997},
	month = {January},
	abstract = {
	
	Of late it has become very common for resarch compilerrs to emit C as their target code, relying on a C compiler to generate machine code. In effect, C is being used as a portable compiler target language. It offers a simple and effective way of avoiding the need to re-implement effective register allocation, instruction selection, and instruction scheduling, and so on, all for a variety of target architectures. The trouble is that C was designed as a programming language not as a compiler target language, and is not very suitable for the latter purpose. The obvious thing to do is to define a language that is designed as a portable target language. This describes C–, a portable compiler target language, or assembler. C– has to strike a balance between being high-level enough to allow the back end a fair crack of the whip, while being low level enough to give the front end the control it needs. It is not clear that a path exists between these two rocks; the ghost of UNCOL lurks ominously in the shadows. Yet the increasing popularity of C as a compiler target language (despite its unsuitability) suggests strong demand, and provides an existence proof that something useful can be done.
	
	
	},
	publisher = {Springer Verlag},
	url = {https://www.microsoft.com/en-us/research/publication/c-a-portable-assembly-language/},
	address = {},
	pages = {1–19},
	journal = {},
	volume = {1467},
	chapter = {},
	isbn = {},
}
@inproceedings{faster-laziness-using-dynamic-pointer-tagging,
	author = {Marlow, Simon and Yakushev, Alexey Rodriguez and Peyton Jones, Simon},
	title = {Faster laziness using dynamic pointer tagging},
	booktitle = {ICFP '07: Proceedings of the ACM SIGPLAN international conference on Functional programming},
	year = {2007},
	month = {October},
	abstract = {
	
	In the light of evidence that Haskell programs compiled by GHC exhibit large numbers of mispredicted branches on modern processors, we re-examine the "tagless" aspect of the STG-machine that GHC uses as its evaluation model.
	
	We propose two tagging strategies: a simple strategy called semi-tagging that seeks to avoid one common source of unpredictable indirect jumps, and a more complex strategy called dynamic pointer-tagging that uses the spare low bits in a pointer to encode information about the pointed-to object. Both of these strategies have been implemented and exhaustively measured in the context of a production compiler, GHC, and the paper contains detailed descriptions of the implementations. Our measurements demonstrate significant performance improvements (14% for dynamic pointer-tagging with only a 2% increase in code size), and we further demonstrate that much of the improvement can be attributed to the elimination of mispredicted branch instructions.
	
	As part of our investigations we also discovered that one optimisation in the STG-machine, vectored-returns, is no longer worthwhile and we explain why.
	
	Wiki talk page for discussion
	
	
	},
	publisher = {ACM Press},
	url = {https://www.microsoft.com/en-us/research/publication/faster-laziness-using-dynamic-pointer-tagging/},
	address = {},
	pages = {},
	journal = {},
	volume = {},
	chapter = {},
	isbn = {},
}
